bridge — Today at 5:59 AM
  Hi Benjamin, I found in the config file
  LINES2ATTACK = ["62_58_180", "62_63_160", "48_50_136", "48_53_141", "41_48_131", "39_41_121",
                    "43_44_125", "44_45_126", "34_35_110", "54_58_154"]
  It seems strange for me .... what should I do to find the line's index?

Benjamin D. — Today at 6:00 AM
  Hello,
  Yes indeed we calibrated the opponent to "attack" only these lines
  You have the attribute (accessible in all classes): env.name_line (or obs.name_line, or act.name_line etc.)
  That gives you the name of the powerlines
  
Configuracion opponent neurips 2021:

lines_attacked = ["62_58_180", "62_63_160", "48_50_136", "48_53_141", "41_48_131", "39_41_121",
                  "43_44_125", "44_45_126", "34_35_110", "54_58_154"]

opponent_attack_cooldown = 12  # 1 hour, 1 hour being 12 time steps
opponent_attack_duration = 96  # 8 hours at maximum
opponent_budget_per_ts = 0.17  # opponent_attack_duration / opponent_attack_cooldown + epsilon
opponent_init_budget = 144.  # no need to attack straightfully, it can attack starting at midday the first day


https://ogb.stanford.edu/docs/leader_graphprop/
https://arxiv.org/abs/2005.03675
https://www.cs.mcgill.ca/~wlh/grl_book/


Convertir gif a png:
$ convert Scenario_april_000.gif target.png

Como es que a mi me da de maximo 519 acciones pero PARL dice que lo reduce a 1000 acciones en el paper?

En el PARL me da que hay 494 acciones posibles si hay el print de self_action_space.size().
Sera que las 1000 acciones son combinando varias?.


crisco — 08/10/2021

Quick question about action space size. In the grid2op getting started notebook 4 (04_TrainingAnAgent.ipynb) the random agent encodes actions as integers. Playing around with this I noticed the agent generated numbers from 0-450 inclusive (this is on the rte_case14_redisp environment) 
however when calling env.action_space.n to get the size of the action space this returned the value 157. What is the cause of the mismatch are not all the randomly generated integers unique possible actions?
Benjamin D. — 08/10/2021
Hello,
This is a really good question :blush:

In fact it depends on what you counts, and how you count it.

The action space is both discrete (for topology and line status) and countinuous (for redispatching and curtailment). As far as I know there is no direct definition of "dimensions" in this case. And it all comes down to how you count discrete actions.
For example, you can say you discretize everything (transforming redispatching and curtailment to discrete value) and then you count (because now every actions is discrete you can do that) how many possible different actions you have. This will give 450 or something like that.
Another way is to count it more like "continuous space", which is:
- you got 1 dimension per generator for the redispatching
- 1 dimension per generator for the curtailment (if activated, I don't remember for this env in particular)
- 1 dimension for each powerline (i set it to "connected" or set it to "disconnected" or don't set it at all)
- 1 dimension for each powerline change status
- 1 dimension for each element (set bus)
-1 dimension for each element (change bus)

And if you count it like that, you get 157, this is the way it's encoded by default in grid2op.
You can also mix things and get pretty much all numbers in between (for example you keep counting the countinuous actions like the second method I mentioned, but counts the unitary actions for the discrete ones)


Idea.. armar 'buckets' segun conexiones del grafico y loads/generators en cada una.
Podemos hacer search para hallar la accion de conexion/desconexion/redispatch que lleve a la mejor bucket ??.

matriz de incidencia/ algo asi ???

grafico siempre igual, ver de no cortar lineas y solo redispatch generators y cambiar buses??


Parametros de competencia:
  "competition": {
    "NO_OVERFLOW_DISCONNECTION":  false, // Se desconecta linea cuando hay supera su termal limit
    "NB_TIMESTEP_OVERFLOW_ALLOWED": 3, // Number of timesteps for which a soft overflow is allowed, default 2. This means that a powerline will be disconnected (if :attr:`.NO_OVERFLOW_DISCONNECTION` is set to ``False``) after 2 time steps above its thermal limit. This is called a "soft overflow".
    "NB_TIMESTEP_COOLDOWN_SUB": 3, // When someone changes the topology of a substations, this number indicates how many timesteps the :class:`grid2op.Agent.BaseAgent` has to wait before being able to modify the topology on this same substation. It has the same behaviour as :attr:`Parameters.NB_TIMESTEP_LINE_STATUS_REMODIF`.
    "NB_TIMESTEP_COOLDOWN_LINE": 3, // When someone acts on a powerline by changing its status (connected / disconnected) this number indicates how many timesteps the :class:`grid2op.Agent.BaseAgent` has to wait before being able to modify this status again. For examle, if this is 1, this means that an BaseAgent can act on status of a powerline 1 out of 2 time step (1 time step it acts, another one it cools down, and the next one it can act again). Having it at 0 it equivalent to deactivate this feature (default).
    "HARD_OVERFLOW_THRESHOLD": 2, // If a the powerflow on a line is above HARD_OVERFLOW_THRESHOLD * thermal limit (and attr:`Parameters.NO_OVERFLOW_DISCONNECTION` is set to ``False``) then it is automatically disconnected, regardless of the number of timesteps it is on overflow). This is called a "hard overflow". This is expressed in relative value of the thermal limits, for example, if for a powerline the `thermal_limit` is 150 and the HARD_OVERFLOW_THRESHOLD is 2.0, then if the flow on the powerline reaches 2 * 150 = 300.0 the powerline the powerline is automatically disconnected.
    "NB_TIMESTEP_RECONNECTION": 12, // Number of timesteps a powerline disconnected for security motives (for example due to :attr:`.NB_TIMESTEP_POWERFLOW_ALLOWED` or :attr:`.HARD_OVERFLOW_THRESHOLD`) will remain disconnected.
    "IGNORE_MIN_UP_DOWN_TIME": true, // Whether or not to ignore the attributes `gen_min_uptime` and `gen_min_downtime`. Basically setting this parameter to ``True``
    "ALLOW_DISPATCH_GEN_SWITCH_OFF": true, // allow dispatch on turned off generator (if ``True`` you can actually dispatch a turned on geenrator)
    "ENV_DC": false,
    "FORECAST_DC": false,
    "MAX_SUB_CHANGED": 1, // Maximum number of substations that can be reconfigured between two consecutive timesteps by an :class:`grid2op.Agent.BaseAgent`. Default value is 1.
    "MAX_LINE_STATUS_CHANGED": 1, // Maximum number of powerlines statuses that can be changed between two consecutive timesteps by an :class:`grid2op.Agent.BaseAgent`. Default value is 1.
    "ALARM_BEST_TIME": 7, // Number of step for which it's best to send an alarm BEFORE a game over
    "ALARM_WINDOW_SIZE": 5 // Number of steps for which it's worth it to give an alarm (if an alarm is send outside of the window `[ALARM_BEST_TIME - ALARM_WINDOW_SIZE, ALARM_BEST_TIME + ALARM_WINDOW_SIZE]` then it does not grant anything
  }


Oponente:

    lines_attacked = ["62_58_180", "62_63_160", "48_50_136", "48_53_141", "41_48_131", "39_41_121",
                  "43_44_125", "44_45_126", "34_35_110", "54_58_154"]
    rho_normalization = [0.45, 0.45, 0.6, 0.35, 0.3, 0.2,
                         0.55, 0.3, 0.45, 0.55]
    opponent_attack_cooldown = 12*24  # 24 hours, 1 hour being 12 time steps
    opponent_attack_duration = 12*4  # 4 hours
    opponent_budget_per_ts = 0.16667  # opponent_attack_duration / opponent_attack_cooldown + epsilon
    opponent_init_budget = 144.  # no need to attack straightfully, it can attack starting at midday the first day
    config = {
        "opponent_attack_cooldown": opponent_attack_cooldown,
        "opponent_attack_duration": opponent_attack_duration,
        "opponent_budget_per_ts": opponent_budget_per_ts,
        "opponent_init_budget": opponent_init_budget,
        "opponent_action_class": PowerlineSetAction,
        "opponent_class": WeightedRandomOpponent,
        "opponent_budget_class": BaseActionBudget,
        'kwargs_opponent': {"lines_attacked": lines_attacked,
                            "rho_normalization": rho_normalization,
                            "attack_period": opponent_attack_cooldown}
    }

- `opponent_attack_cooldown`: give the minimum number of time between two attacks (here 1 attack per day)
- `opponent_attack_duration`: duration for each attack (when a line is attacked, it will not be possible to reconnect
  it for that many steps). In the example it's 4h (so 48 steps)
- `opponent_action_class`: type of the action the opponent will perform (in this case `PowerlineSetAction`)
- `opponent_class`: type of the opponent. Change it at your own risk.
- `opponent_budget_class`: Each attack will cost some budget to the opponent. If no budget, the opponent cannot
  attack. This specifies how the budget are computed. Do not change it.
- `opponent_budget_per_ts`: increase of the budget of the opponent per step. The higher this number, the faster the
  the opponent will regenerate its budget.
- `opponent_init_budget`: initial opponent budget. It is set to 0 to "give" the agent a bit of time before the opponent
  is triggered.
- `kwargs_opponent`: additional information for the opponent. In this case we provide for each grid the powerline it
  can attack.

Factorizar action space:

https://openreview.net/pdf?id=naSAkn2Xo46

black box optimization:

https://dl.acm.org/doi/pdf/10.1145/3377930.3389838


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Idea del problema de que reward al final del episodio seria un problema:

Generar episodios mas chicos a partir de los cuales donde pierde. Hacer que comienze N estados antes de perder y ver que el agente aprenda a resolver esos !.

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

gym parametrizacion de obs:

ALL_ATTR_OBS = ("year", "month", "day", "hour_of_day", "minute_of_hour",
                "day_of_week",
                "gen_p", "gen_q", "gen_v",
                "load_p", "load_q", "load_v",
                "p_or", "q_or", "v_or", "a_or",
                "p_ex", "q_ex", "v_ex", "a_ex",
                "rho", "line_status",
                "timestep_overflow", "topo_vect", "time_before_cooldown_line",
                "time_before_cooldown_sub", "time_next_maintenance",
                "duration_next_maintenance", "target_dispatch", "actual_dispatch",
                "storage_charge", "storage_power_target", "storage_power", "curtailment",
                "curtailment_limit", "thermal_limit",

                "is_alarm_illegal", "time_since_last_alarm", "last_alarm", "attention_budget",
                "was_alarm_used_after_game_over"
                )

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


State abstraction: https://github.com/anonicml2019/icml_2019_state_abstraction
con codigo: https://github.com/anonicml2019/icml_2019_state_abstraction

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
